---
title: "Collatz Sequences"
author: Dan Reznik
date: April 2019
output: github_document
---

A Collatz *Sequence* starts with N, a positive integer. The next term in the sequence is obtained from the current one as follows:

* If current is even, next is half the current: `coll[i+1] = coll[i]/2`
* If current is odd, next is 3 times the current plus 1: `coll[i+1] = 3*coll[i]+1`

The Collatz *Conjecture* states that for all starting N's, the sequence will always reach 1, explained [here](https://en.wikipedia.org/wiki/Collatz_conjecture).

Below we investigate basics of Collatz sequences with starting N from 1 to 10k, namely:

* for each N calculate the sequence and its length
* pick a starting N (e.g, 27) which produces an unusually long sequence
* study the distribution of the ratio of seq_length/N
* show the starting N's with largest seq_length/N ratios

```{r,echo=F}
knitr::opts_chunk$set(
  cache=T,
  collapse=T,
  comment="#>",
  dpi=300,
  fig.align="center",
  out.width='100%'
)
```

Load libraries

```{r,message=F}
library(tidyverse)
library(gtools) # for even()
library(furrr)
library(tictoc)
library(fs)
```

Calculate Collatz sequence with `purrr::accumulate()`

```{r}
collatz <- function(x,y) if (x%in%c(1L,2L)) done(1L) else if (even(x)) x/2L else 3L*x+1L
get_seq_seq <- function(x) (1L:10000L)%>%accumulate(collatz,.init=x)%>%as.integer
```

Compute (in parallel) first 100k Collatz sequences, and show them for N=20...30

```{r}
fname_coll <- "data/df_coll.rds"
n_max <- 100e3
tic()
if (file_exists(fname_coll)) { # avoid long calc w/ knitr
  df_coll <- read_rds(fname_coll)
} else {
  plan(multiprocess)
  df_coll <- tibble(n=1:n_max,
                    coll=n%>%future_map(get_seq_seq),
                    seq_s=coll%>%map_chr(str_c,collapse=";"),
                    seq_max=coll%>%map_int(max),
                    seq_l=coll%>%map_int(length)) %>%
    select(n,seq_l,seq_max,seq_s)
  # Save it to RDS
  df_coll %>% write_rds(fname_coll,compress = "bz")
}
toc()
```

```{r,echo=F}
df_coll %>%
  slice(20:30) %>%
  knitr::kable()
```

The N=27 sequence

```{r}
coll27 <- df_coll%>%filter(n==27)%>%pull(seq_s)
tibble(x=coll27%>%str_split(";")%>%first%>%as.integer)%>%mutate(i=row_number()) %>%
  ggplot(aes(i,x))+
  geom_line(color="blue") + geom_point(color="black") +
  scale_y_log10() + 
  labs(title="N=27",
       y="collatz[i] (log scale)",x="Iteration")
```

Plot sequence lengths vs starting N

```{r}
df_coll %>%
  ggplot(aes(n,seq_l)) +
  geom_line(alpha=.2) +
  geom_smooth() +
  labs(x='starting N',y='sequence length')
```

Mean and Median of length/n

```{r}
map2_dbl(df_coll$seq_l,df_coll$n,~.x/.y)%>%mean
map2_dbl(df_coll$seq_l,df_coll$n,~.x/.y)%>%median
```

Top ten ratios of sequence lengths by starting N

```{r}
df_coll %>%
  mutate(ratio=seq_l/n) %>%
  arrange(desc(ratio)) %>% 
  head(10) %>%
  mutate(rank=row_number(),ratio=round(ratio,2)) %>%
  select(rank,n,seq_l,ratio,everything()) %>%
  knitr::kable()
```

Plot density of sequence lengths divided by starting N. Can the mode be computed?

```{r,message=F}
df_coll %>%
  ggplot(aes(seq_l/n)) +
  geom_freqpoly(aes(y = ..density..)) +
  scale_x_log10() +
  labs(x='seq_length/starting N',
       y='density')
```

```{r,include=F}
ggsave("pics/steps_required.png",width=10,height=4)
```

Happy Collatzing!
